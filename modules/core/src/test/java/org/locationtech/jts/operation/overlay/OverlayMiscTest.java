package org.locationtech.jts.operation.overlay;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.junit.Assert;
import org.junit.Test;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryCollection;
import org.locationtech.jts.geom.GeometryFactory;
import org.locationtech.jts.geom.LineString;
import org.locationtech.jts.geom.MultiPolygon;
import org.locationtech.jts.geom.Polygon;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;
import org.locationtech.jts.operation.overlayng.OverlayNG;
import org.locationtech.jts.operation.overlayng.OverlayNGRobust;
import org.locationtech.jts.planargraph.DirectedEdgeTest;

import junit.textui.TestRunner;
import test.jts.GeometryTestCase;

public class OverlayMiscTest extends GeometryTestCase 
{
  public static void main(String args[]) {
    TestRunner.run(OverlayMiscTest.class);
  }

  public OverlayMiscTest(String name)
  {
    super(name);
  }
  
  public void testNoding() throws Exception {
    Geometry a = read("LINESTRING(0 0, 100 100)");
    Geometry b = read("LINESTRING(0 100, 100 0)");
    List lineStrings = Arrays.asList(new Object[] {a, b});
    Geometry nodedLineStrings = (LineString) lineStrings.get(0);
    for (int i = 1; i < lineStrings.size(); i++) {
      nodedLineStrings = nodedLineStrings.union((LineString)lineStrings.get(i));
    }
    assertEquals("MULTILINESTRING ((0 0, 50 50), (50 50, 100 100), (0 100, 50 50), (50 50, 100 0))", nodedLineStrings.toString());
  }



  public void testNoOutgoingDirEdgeFoundException() throws Exception {
      Geometry a = new WKTReader().read("MULTIPOLYGON (((1668033.7441322226 575074.5372325261, 1668043.6526485088 575601.4901441064, 1668049.5076808596 575876.2262774946, 1668054.4619390026 576155.4662819218, 1668057.61464873 576428.4008668943, 1668059.8665842495 576711.2439681528, 1668063.9200681846 576991.3847467878, 1668071.576648951 577269.7239770072, 1668075.630132886 577547.1624330188, 1668077.8820684056 577825.5016632382, 1668081.935552341 578102.9401192497, 1668087.7905846918 578380.3785752613, 1668094.5463912506 578650.6108376103, 1668097.699100978 578919.9423257514, 1668103.5541333288 579191.0753623082, 1668111.2107140953 579455.9029794101, 1668112.5230371233 579490.6388405386, 1668120.62746972 579490.4954984378, 1668113.4626496148 579183.8691686456, 1668108.5083914716 578916.3392289202, 1668104.4549075365 578642.50386974, 1668100.401423601 578368.6685105597, 1668094.54639125 578095.7339255873, 1668088.6913588992 577822.7993406148, 1668085.5386491718 577548.9639814346, 1668082.3859394444 577275.1286222544, 1668076.5309070935 577002.1940372819, 1668072.4774231582 576729.2594523095, 1668066.6223908074 576456.324867337, 1668063.46968108 576183.3902823646, 1668059.416197145 575910.4556973921, 1668055.3627132094 575637.5211124197, 1668052.210003482 575366.3880758629, 1668046.354971131 575097.9573619296, 1668046.805358235 575068.2318130712, 1668033.7441322226 575074.5372325261)))");
      Geometry b = new WKTReader().read("MULTIPOLYGON (((1665830.62 580116.54, 1665859.44 580115.84, 1666157.24 580108.56, 1666223.3 580107.1, 1666313 580105.12, 1666371.1 580103.62, 1666402 580102.78, 1666452.1 580101.42, 1666491.02 580100.36, 1666613.94 580097.02, 1666614.26 580097.02, 1666624 580096.74, 1666635.14 580096.42, 1666676.16 580095.28, 1666722.42 580093.94, 1666808.26 580091.44, 1666813.42 580091.3, 1666895.02 580088.78, 1666982.06 580086.1, 1667067.9 580083.46, 1667151.34 580080.88, 1667176.8 580080.1, 1667273.72 580077.14, 1667354.54 580074.68, 1667392.4 580073.88, 1667534.24 580070.9, 1667632.7 580068.82, 1667733.94 580066.68, 1667833.62 580064.58, 1667933.24 580062.5, 1667985 580061.4, 1668033.12 580060.14, 1668143.7 580057.24, 1668140.64 579872.78, 1668134.7548600042 579519.7278276943, 1668104.737250423 579518.9428425882, 1668110.64 579873.68, 1668113.18 580025.46, 1668032.4 580027.46, 1667932.66 580030.08, 1667832.8 580032.58, 1667632.28 580037.78, 1667392.14 580043.78, 1667273.4 580046.72, 1667150.62 580049.46, 1667067.14 580051.78, 1666981.14 580053.84, 1666807.4 580057.96, 1666613.64 580062.58, 1666490.14 580065.78, 1666400.9 580067.78, 1666312.18 580070.36, 1666222.1 580072.6, 1665859.28 580079.52, 1665830.28 580080.14, 1665830.62 580116.54)), ((1668134.2639058917 579490.2543124713, 1668130.62 579270.86, 1668125.86 578984.78, 1668117.3 578470.2, 1668104.02 577672.06, 1668096.78 577237.18, 1668093.4 577033.64, 1668087.28 576666.92, 1668085.24 576543.96, 1668083.32 576428.36, 1668081.28 576305.86, 1668075.38 575950.9, 1668061.12 575018.44, 1666745.6 575072.62, 1665835.48 575109.72, 1665429.26 575126.26, 1664940.66 575148.86, 1664365.4 575170.64, 1664116.02 575181.78, 1662804.22 575230.32, 1662804.780409841 575260.319992344, 1664086.52 575208.92, 1664150.3090003466 579072.2660557877, 1664180.345101783 579073.7529915024, 1664174.46 578717.2, 1664204.44 578716.82, 1664173.3 576830.12, 1664146.48 575206.52, 1665410.98 575155.82, 1665439.18 576784.24, 1665441.16 576899.44, 1665441.88 576940.4, 1665478.5547472103 579058.5389785315, 1665518.6155320513 579061.3502616781, 1665450.98 575156.2, 1668030.38 575050.3, 1668104.2687072477 579490.7848338542, 1668134.2639058917 579490.2543124713)), ((1664150.7710040906 579100.2470608585, 1664160.68 579700.38, 1664165.68 579987.66, 1664195.2 579986.98, 1664190.68 579699.9, 1664180.7918241904 579100.8179797827, 1664150.7710040906 579100.2470608585)), ((1665478.9532824333 579081.5562602862, 1665483.38 579337.22, 1665503.38 579336.64, 1665505.06 579443.26, 1665525.22 579442.68, 1665522.9750161383 579313.0587927903, 1665513.4612495075 579308.8304520656, 1665510.9439672586 579258.4848070825, 1665510.9439672586 579114.9997188805, 1665503.392120511 579082.2750496415, 1665478.9532824333 579081.5562602862)))");
      a.difference(b);
      b.difference(a);
  }


  @Test
  /**
   * Test a intersection with a very narrow geometry close to the border using a for loop.
   * 
   * This works OK and we return the very narrow polygons
   *  
   * @throws ParseException
   */
  public void test_7_Intersection_loop() throws ParseException {

      Geometry g1= new WKTReader().read("POLYGON ((5.171796850040617 61.63109289654953, 5.171796676245829 61.63109295594216, 5.171765430643211 61.63109513643147, 5.17171972428688 61.63110275399046, 5.171693714982271 61.63111146271694, 5.17165467365684 61.631121693785616, 5.171647369933198 61.631123368287206, 5.171585767657087 61.631155078277516, 5.17157056467294 61.63116346060828, 5.171554021565499 61.63117504109626, 5.171510591367186 61.63121921397677, 5.171472849060388 61.631287634284774, 5.171431175423897 61.631360348585645, 5.171410832239342 61.63138889993328, 5.171369882904709 61.631423704808434, 5.17134097067367 61.631445185087415, 5.171322078939662 61.63146505865625, 5.171300404098109 61.631515054192896, 5.171288682554027 61.631544777638794, 5.171272603528746 61.631585550662514, 5.171264482517947 61.63162370220873, 5.171263616533105 61.631641384465254, 5.17126323358138 61.63164860015275, 5.171270591021064 61.63164912989441, 5.171294515991664 61.63165085584459, 5.171305224690445 61.63165162836994, 5.171350771945397 61.63165336444806, 5.171357855375412 61.631631252842645, 5.171413619065784 61.63163529798867, 5.171422119715523 61.63160876219859, 5.171533647053681 61.63161685241401, 5.171542147594096 61.631590316614194, 5.17176520228535 61.63160649675632, 5.171773702623785 61.631579960937884, 5.1723871038916736 61.63162445441739, 5.172404103499401 61.63157138268005, 5.172348339756998 61.63156733794006, 5.172365339390634 61.63151426620851, 5.17242110304039 61.63151831093958, 5.1724126032782385 61.6315448468102, 5.1725241307204435 61.63155293621354, 5.172532630389954 61.63152640033399, 5.172588394089763 61.63153044499734, 5.17260539328609 61.63147737322696, 5.1726611569099346 61.631481417858794, 5.172678155946876 61.631428346076376, 5.172733919494761 61.631432390676736, 5.1727594177860885 61.63135278298381, 5.172815181211687 61.63135682754822, 5.172840679213901 61.63127721983486, 5.1730079691739075 61.63128935335251, 5.172999469995483 61.631315889271136, 5.173055233395172 61.63131993373632, 5.173046734246392 61.6313464696586, 5.173158261188462 61.631354558530205, 5.17313276391995 61.631434166319124, 5.173077000301604 61.63143012188125, 5.173060001946544 61.63148319372768, 5.173004238252239 61.6314791492583, 5.172987239737798 61.631532221092684, 5.17293147596753 61.63152817659181, 5.172905977931779 61.63160778432411, 5.172961741841018 61.631611828838345, 5.172970241156623 61.63158529292391, 5.173026005036225 61.631589337411135, 5.173034504288828 61.63156280149145, 5.173090268138785 61.631566845951625, 5.173098767328383 61.63154031002671, 5.1731545311487 61.63154435445985, 5.173163030275293 61.631517818529666, 5.173218794065968 61.631521862935784, 5.173227293129557 61.631495327000366, 5.1732830568905905 61.63149937137947, 5.173291555891169 61.63147283543881, 5.1733331657906385 61.631475853262, 5.17334589872798 61.631469721527424, 5.173350581238179 61.63146669613823, 5.173372816385254 61.63139727195077, 5.173428579994363 61.63140131626687, 5.173446141375093 61.631346484215555, 5.173450425130651 61.631321443589385, 5.1734522570350405 61.6313107352209, 5.1734524972988885 61.631185832191626, 5.173440807018409 61.631184984342674, 5.173449305772492 61.63115844838812, 5.173393542596964 61.63115440408958, 5.1734020413806805 61.6311278681387, 5.173123225984876 61.631107646329674, 5.17313172498352 61.63108111040032, 5.17268562158828 61.63104875436774, 5.172677122219062 61.63107529026145, 5.172565596444439 61.631067201018645, 5.172548597470678 61.63112027278586, 5.172492834515744 61.63111622812168, 5.1724673357910245 61.63119583575317, 5.172411572713812 61.631191791053055, 5.172352074781295 61.63137754213452, 5.172240548028423 61.63136945260412, 5.172257547706421 61.631316380888315, 5.172201784447651 61.63131233609816, 5.1722442835822795 61.63117965681724, 5.1721885205718054 61.63117561202681, 5.172197020394999 61.63114907617274, 5.172141257447527 61.63114503136419, 5.172149757300357 61.631118495513796, 5.1720939944158895 61.63111445068714, 5.172102494298358 61.631087914840414, 5.171935205884021 61.631075780238405, 5.171926705862584 61.63110231607178, 5.171796850040617 61.63109289654953))");
      double area1 = g1.getArea();
      Geometry g2=new WKTReader().read("MULTIPOLYGON (((5.17165467365684 61.631121693785616, 5.171647369933198 61.631123368287206, 5.171585767657087 61.631155078277516, 5.17157056467294 61.63116346060828, 5.171584599055308 61.63115572259883, 5.171585767657088 61.631155078277516, 5.1716449403479 61.631124618924865, 5.171647369933206 61.631123368287206, 5.17165467365684 61.631121693785616)), ((5.1714526857206184 61.63132281631538, 5.171431175423897 61.631360348585645, 5.171410832239342 61.63138889993328, 5.171431175423889 61.631360348585666, 5.1714526857206184 61.63132281631538)), ((5.171369882904709 61.631423704808434, 5.17134097067367 61.631445185087415, 5.171322078939662 61.63146505865625, 5.171322078939656 61.63146505865626, 5.171340970673664 61.63144518508743, 5.171355403249634 61.63143446243659, 5.171369882904709 61.631423704808434)), ((5.171320993973893 61.63146756125566, 5.171300404098109 61.631515054192896, 5.171300404024736 61.63151505437896, 5.171300404098101 61.63151505419292, 5.171308477044493 61.63149643300548, 5.171320993973893 61.63146756125566)), ((5.171263616533105 61.631641384465254, 5.17126323358138 61.63164860015275, 5.171270591021064 61.63164912989441, 5.171265335707341 61.631648751507534, 5.1712632335813815 61.63164860015275, 5.1712634250572425 61.631644992309006, 5.171263616533105 61.631641384465254)), ((5.171270591021064 61.63164912989441, 5.171294515991664 61.63165085584459, 5.171305224690445 61.63165162836994, 5.171270598747127 61.63164913045177, 5.171270591021064 61.63164912989441)), ((5.171305224690445 61.63165162836994, 5.171350771945397 61.63165336444806, 5.171357855375412 61.631631252842645, 5.1713507719482 61.63165336443931, 5.171305224690445 61.63165162836994)))");
      double area2 =  g2.getArea();
      Assert.assertTrue(g1.isValid());
      Assert.assertTrue(g2.isValid());
      Assert.assertTrue(area1 > 0);
      Assert.assertTrue(area2 > 0);
      
      ArrayList<Geometry> newGeoList = new ArrayList<Geometry>();

     
      for (int i = 0; i < g2.getNumGeometries(); i++) {
          Geometry g2GeoN = g2.getGeometryN(i);
          for (int y = 0; y < g1.getNumGeometries(); y++) {
              Geometry g1GeoN = g1.getGeometryN(y);
              Geometry cleanIntersection = g1GeoN.intersection(g2GeoN);
              cleanIntersection.getGeometryType();
              newGeoList.add(cleanIntersection);
          }
      }

      GeometryFactory geometryFactory = new GeometryFactory();

      GeometryCollection loop_intersection = geometryFactory.createGeometryCollection(((Geometry[]) newGeoList.toArray(new Geometry[0])));
      double loop_intersection_area =  loop_intersection.getArea();

      
      Assert.assertTrue(loop_intersection.isValid());
      Assert.assertTrue(loop_intersection_area > 0);
      Assert.assertTrue("To big intersection related to input area1:" + area1 + " loop_intersection:" + loop_intersection_area, loop_intersection_area <= area1  );
      Assert.assertTrue("To big intersection related to input area2:" + area2 + " loop_intersection:" + loop_intersection_area, loop_intersection_area <= area2  );

      // buffer out a tiny part just part to avoid to be sure to avoid rounding error
      double distance = 0.0000000001;
      ArrayList<Polygon> g1bufferout_polygon_list = resolveAreaGeos(g1.buffer(distance));
      ArrayList<Polygon> g2bufferout_polygon_list = resolveAreaGeos(g2.buffer(distance));
      ArrayList<Polygon> intersection_polygon_list = resolveAreaGeos(loop_intersection);
      testThatIntersectionIsCoveredByInput(g1bufferout_polygon_list, g2bufferout_polygon_list, intersection_polygon_list);


  }

  @Test
  /**
   * Test a intersection with a very narrow geometry close to the border using a for loop.
   * 
   * This is falling now and returns the big area and not the narrow area.
   * 
   * Failed tests: 
   * java.lang.AssertionError: To big intersection related to input area2:2.1960576832560605E-16 overlayNGRobust_intersection:2.0040991178807718E-7
   *  
   * @throws ParseException
   */
  public void test_7_Intersection_OverlayNGRobust() throws ParseException {

      Geometry g1= new WKTReader().read("POLYGON ((5.171796850040617 61.63109289654953, 5.171796676245829 61.63109295594216, 5.171765430643211 61.63109513643147, 5.17171972428688 61.63110275399046, 5.171693714982271 61.63111146271694, 5.17165467365684 61.631121693785616, 5.171647369933198 61.631123368287206, 5.171585767657087 61.631155078277516, 5.17157056467294 61.63116346060828, 5.171554021565499 61.63117504109626, 5.171510591367186 61.63121921397677, 5.171472849060388 61.631287634284774, 5.171431175423897 61.631360348585645, 5.171410832239342 61.63138889993328, 5.171369882904709 61.631423704808434, 5.17134097067367 61.631445185087415, 5.171322078939662 61.63146505865625, 5.171300404098109 61.631515054192896, 5.171288682554027 61.631544777638794, 5.171272603528746 61.631585550662514, 5.171264482517947 61.63162370220873, 5.171263616533105 61.631641384465254, 5.17126323358138 61.63164860015275, 5.171270591021064 61.63164912989441, 5.171294515991664 61.63165085584459, 5.171305224690445 61.63165162836994, 5.171350771945397 61.63165336444806, 5.171357855375412 61.631631252842645, 5.171413619065784 61.63163529798867, 5.171422119715523 61.63160876219859, 5.171533647053681 61.63161685241401, 5.171542147594096 61.631590316614194, 5.17176520228535 61.63160649675632, 5.171773702623785 61.631579960937884, 5.1723871038916736 61.63162445441739, 5.172404103499401 61.63157138268005, 5.172348339756998 61.63156733794006, 5.172365339390634 61.63151426620851, 5.17242110304039 61.63151831093958, 5.1724126032782385 61.6315448468102, 5.1725241307204435 61.63155293621354, 5.172532630389954 61.63152640033399, 5.172588394089763 61.63153044499734, 5.17260539328609 61.63147737322696, 5.1726611569099346 61.631481417858794, 5.172678155946876 61.631428346076376, 5.172733919494761 61.631432390676736, 5.1727594177860885 61.63135278298381, 5.172815181211687 61.63135682754822, 5.172840679213901 61.63127721983486, 5.1730079691739075 61.63128935335251, 5.172999469995483 61.631315889271136, 5.173055233395172 61.63131993373632, 5.173046734246392 61.6313464696586, 5.173158261188462 61.631354558530205, 5.17313276391995 61.631434166319124, 5.173077000301604 61.63143012188125, 5.173060001946544 61.63148319372768, 5.173004238252239 61.6314791492583, 5.172987239737798 61.631532221092684, 5.17293147596753 61.63152817659181, 5.172905977931779 61.63160778432411, 5.172961741841018 61.631611828838345, 5.172970241156623 61.63158529292391, 5.173026005036225 61.631589337411135, 5.173034504288828 61.63156280149145, 5.173090268138785 61.631566845951625, 5.173098767328383 61.63154031002671, 5.1731545311487 61.63154435445985, 5.173163030275293 61.631517818529666, 5.173218794065968 61.631521862935784, 5.173227293129557 61.631495327000366, 5.1732830568905905 61.63149937137947, 5.173291555891169 61.63147283543881, 5.1733331657906385 61.631475853262, 5.17334589872798 61.631469721527424, 5.173350581238179 61.63146669613823, 5.173372816385254 61.63139727195077, 5.173428579994363 61.63140131626687, 5.173446141375093 61.631346484215555, 5.173450425130651 61.631321443589385, 5.1734522570350405 61.6313107352209, 5.1734524972988885 61.631185832191626, 5.173440807018409 61.631184984342674, 5.173449305772492 61.63115844838812, 5.173393542596964 61.63115440408958, 5.1734020413806805 61.6311278681387, 5.173123225984876 61.631107646329674, 5.17313172498352 61.63108111040032, 5.17268562158828 61.63104875436774, 5.172677122219062 61.63107529026145, 5.172565596444439 61.631067201018645, 5.172548597470678 61.63112027278586, 5.172492834515744 61.63111622812168, 5.1724673357910245 61.63119583575317, 5.172411572713812 61.631191791053055, 5.172352074781295 61.63137754213452, 5.172240548028423 61.63136945260412, 5.172257547706421 61.631316380888315, 5.172201784447651 61.63131233609816, 5.1722442835822795 61.63117965681724, 5.1721885205718054 61.63117561202681, 5.172197020394999 61.63114907617274, 5.172141257447527 61.63114503136419, 5.172149757300357 61.631118495513796, 5.1720939944158895 61.63111445068714, 5.172102494298358 61.631087914840414, 5.171935205884021 61.631075780238405, 5.171926705862584 61.63110231607178, 5.171796850040617 61.63109289654953))");
      double area1 = g1.getArea();
      Geometry g2=new WKTReader().read("MULTIPOLYGON (((5.17165467365684 61.631121693785616, 5.171647369933198 61.631123368287206, 5.171585767657087 61.631155078277516, 5.17157056467294 61.63116346060828, 5.171584599055308 61.63115572259883, 5.171585767657088 61.631155078277516, 5.1716449403479 61.631124618924865, 5.171647369933206 61.631123368287206, 5.17165467365684 61.631121693785616)), ((5.1714526857206184 61.63132281631538, 5.171431175423897 61.631360348585645, 5.171410832239342 61.63138889993328, 5.171431175423889 61.631360348585666, 5.1714526857206184 61.63132281631538)), ((5.171369882904709 61.631423704808434, 5.17134097067367 61.631445185087415, 5.171322078939662 61.63146505865625, 5.171322078939656 61.63146505865626, 5.171340970673664 61.63144518508743, 5.171355403249634 61.63143446243659, 5.171369882904709 61.631423704808434)), ((5.171320993973893 61.63146756125566, 5.171300404098109 61.631515054192896, 5.171300404024736 61.63151505437896, 5.171300404098101 61.63151505419292, 5.171308477044493 61.63149643300548, 5.171320993973893 61.63146756125566)), ((5.171263616533105 61.631641384465254, 5.17126323358138 61.63164860015275, 5.171270591021064 61.63164912989441, 5.171265335707341 61.631648751507534, 5.1712632335813815 61.63164860015275, 5.1712634250572425 61.631644992309006, 5.171263616533105 61.631641384465254)), ((5.171270591021064 61.63164912989441, 5.171294515991664 61.63165085584459, 5.171305224690445 61.63165162836994, 5.171270598747127 61.63164913045177, 5.171270591021064 61.63164912989441)), ((5.171305224690445 61.63165162836994, 5.171350771945397 61.63165336444806, 5.171357855375412 61.631631252842645, 5.1713507719482 61.63165336443931, 5.171305224690445 61.63165162836994)))");
      double area2 =  g2.getArea();
      Assert.assertTrue(g1.isValid());
      Assert.assertTrue(g2.isValid());
      Assert.assertTrue(area1 > 0);
      Assert.assertTrue(area2 > 0);
      
      Geometry overlayNGRobust_intersection = OverlayNGRobust.overlay(g1, g2, OverlayNG.INTERSECTION);
      double overlayNGRobust_intersection_area =  overlayNGRobust_intersection.getArea();

      Assert.assertTrue(overlayNGRobust_intersection.isValid());
      Assert.assertTrue(overlayNGRobust_intersection_area > 0);
      
      
      double distance = 0.0000000001;
      ArrayList<Polygon> g1bufferout_polygon_list = resolveAreaGeos(g1.buffer(distance));
      ArrayList<Polygon> g2bufferout_polygon_list = resolveAreaGeos(g2.buffer(distance));
      ArrayList<Polygon> intersection_polygon_list = resolveAreaGeos(overlayNGRobust_intersection);
      //if you comment in test testThatIntersectionIsCoveredByInput it will fail with this error
      //OverlayMiscTest.test_7_Intersection_OverlayNGRobust:144->testThatIntersectionIsCoveredByInput:177 input area2 do not cover loop_intersectionN:POLYGON ((5.171796676245829 61.63109295594216, 5.171765430643211 61.63109513643147, 5.17171972428688 61.63110275399046, 5.171693714982271 61.63111146271694, 5.17165467365684 61.631121693785616, 5.171647369933198 61.631123368287206, 5.1716449403479 61.631124618924865, 5.171585767657087 61.631155078277516, 5.171584599055308 61.63115572259883, 5.17157056467294 61.63116346060828, 5.171554021565499 61.63117504109626, 5.171510591367186 61.63121921397677, 5.171472849060388 61.631287634284774, 5.1714526857206184 61.63132281631538, 5.171431175423897 61.631360348585645, 5.171410832239342 61.63138889993328, 5.171369882904709 61.631423704808434, 5.171355403249634 61.63143446243659, 5.17134097067367 61.631445185087415, 5.171322078939662 61.63146505865625, 5.171320993973893 61.63146756125566, 5.171308477044493 61.63149643300548, 5.171300404098109 61.631515054192896, 5.171300404024736 61.63151505437896, 5.171288682554027 61.631544777638794, 5.171272603528746 61.631585550662514, 5.171264482517947 61.63162370220873, 5.171263616533105 61.631641384465254, 5.1712634250572425 61.631644992309006, 5.17126323358138 61.63164860015275, 5.171265335707341 61.631648751507534, 5.171270591021064 61.63164912989441, 5.171270598747127 61.63164913045177, 5.171294515991664 61.63165085584459, 5.171305224690445 61.63165162836994, 5.171350771945397 61.63165336444806, 5.171357855375412 61.631631252842645, 5.171413619065784 61.63163529798867, 5.171422119715523 61.63160876219859, 5.171533647053681 61.63161685241401, 5.171542147594096 61.631590316614194, 5.17176520228535 61.63160649675632, 5.171773702623785 61.631579960937884, 5.171819313556502 61.63158326935801, 5.171819313556502 61.631094526015076, 5.171796850040617 61.63109289654953, 5.171796676245829 61.63109295594216))
      //testThatIntersectionIsCoveredByInput(g1bufferout_polygon_list, g2bufferout_polygon_list, intersection_polygon_list);
      
      Assert.assertTrue("To big intersection related to input area1:" + area1 + " overlayNGRobust_intersection:" + overlayNGRobust_intersection_area, overlayNGRobust_intersection_area <= area1  );
      Assert.assertTrue("To big intersection related to input area2:" + area2 + " overlayNGRobust_intersection:" + overlayNGRobust_intersection_area, overlayNGRobust_intersection_area <= area2  );


  }   

  // A helper method to test that the result is overlapped input polygons
  private void testThatIntersectionIsCoveredByInput(ArrayList<Polygon> g1bufferout_polygon_list,
          ArrayList<Polygon> g2bufferout_polygon_list, ArrayList<Polygon> intersection_polygon_list) {
      for (int i = 0; i < intersection_polygon_list.size(); i++) {
            Geometry loop_intersectionN = intersection_polygon_list.get(i);
            Assert.assertTrue(loop_intersectionN.isValid());
            
            boolean isCoverd_g1 = false;
            for (int ig1 = 0; ig1 < g1bufferout_polygon_list.size(); ig1++) {
                Geometry g1bufferoutN = g1bufferout_polygon_list.get(ig1);
                if (loop_intersectionN.coveredBy(g1bufferoutN)) {
                    isCoverd_g1 = true;
                    break;
                }
            }
            Assert.assertTrue("input area1 do not cover loop_intersectionN:" + loop_intersectionN, isCoverd_g1 );
            
            boolean isCoverd_g2 = false;
            for (int ig2 = 0; ig2 < g2bufferout_polygon_list.size(); ig2++) {
                Geometry g2bufferoutN = g2bufferout_polygon_list.get(ig2);
                if (loop_intersectionN.coveredBy(g2bufferoutN)) {
                    isCoverd_g2 = true;
                    break;
                }
            }
            Assert.assertTrue("input area2 do not cover loop_intersectionN:" + loop_intersectionN, isCoverd_g2 );

        }
  }   



  //  Helper methods to get a list area
  public static ArrayList<Polygon> resolveAreaGeos(Geometry geoToAdd) {
      ArrayList<Polygon> geoList = new ArrayList<Polygon>();
      resolveAreaGeos(geoList, geoToAdd);
      return geoList;
  }

  private static void resolveAreaGeos(ArrayList<Polygon> geoList, Geometry geoToAdd) {
      if (geoToAdd instanceof GeometryCollection) {
          if (geoToAdd.getArea() > 0) {
              for (int x = 0, xx = geoToAdd.getNumGeometries(); x < xx; x++) {
                  resolveAreaGeos(geoList, geoToAdd.getGeometryN(x));
              }
          }
      } else if (geoToAdd instanceof MultiPolygon) {
          for (int x = 0, xx = geoToAdd.getNumGeometries(); x < xx; x++) {
              resolveAreaGeos(geoList, geoToAdd.getGeometryN(x));
          }
      } else if (geoToAdd instanceof Polygon) {
              geoList.add((Polygon) geoToAdd);
      }
  }
      
}
